c++ 관련 필기사항 정리 문서
========================================

[블로그 링크](https://modoocode.com/135)

## 2023-01-18

1. 왜 c++을 배우냐 부분 읽음
2. 1-1 진행함

------------------------------

## 2023-01-19

## 1-2

>iostream  == c언어에서 stdio.h 같은 존재

>std = 이름공간이라는 것(namespace)
	객체가 어디 소속인지 지정해줌

`std::cout` 에서 std가 없으면 cout를 찾을 수 없음.

```c++
// header1.h 의 내용
namespace header1 {
int foo();
void bar();
}

// header2.h 의 내용
namespace header2 {
int foo();
void bar();
}
```
> 이름공간을 정의하는 방법이다.

header1안에서 foo를 부른다면 그 안의 foo를 부르는 셈,
밖에서 부르려면 `header1::foo`가 필요.

하지만 만일 위 같은 `foo` 을 여러번 반복적으로 호출하게 되는 경우 앞에 매번 `header1::` 을 붙이기가 상당히 귀찮을 것입니다.

>그래서 아래와 같이 '나는 앞으로 `header1` 이란 이름 공간에 들어있는 `foo` 만 쓸거다!' 라고 선언할 수 있습니다.

```c++
#include "header1.h"
#include "header2.h"

using header1::foo;
int main() {
  foo();  // header1 에 있는 함수를 호출
}
////////////////////////////////////////////////////
#include "header1.h"
#include "header2.h"
// header1에 있는 공간만 사용 원할시,
using namespace header1;
int main() {
  foo();  // header1 에 있는 함수를 호출
  bar();  // header1 에 있는 함수를 호출
}
// 로 가능. 그렇다고 header2를 못 부르는 건 아니고, 명시적으로 적어주면 가능.

```

std는 iostream 안에 정의된 이름공간임.
이 경우에는, 특별히 std 생략하고 cout, endl만 적어도 가능.

**참고!** 
권장하는 방식은 `using namespace std;` 같은 것은 사용하지 않고, `std::` 를 직접 앞에 붙여서 [std](https://modoocode.com/std) 의 이름공간의 함수이다 라고 명시해주는 것이 좋습니다. 또한, 여러분이 작성하는 코드는 여러분 만의 이름 공간에 넣어서 혹시 모를 이름 충돌로 부터 보호하는 것이 중요합니다.

>cout == 표준 출력 (c언어의 stdout라네요)

>endl == 출력하겠다는 함수(대충 엔터출력정도로 지금은 생각)

잠깐 짚고 넘어가자면, C++ 에서는 재미있게도 이름 공간에 굳이 이름을 설정하지 않아도 됩니다.

이 경우 해당 이름 공간에 정의된 것들은 해당 파일 안에서만 접근할 수 있게 됩니다. 이 경우 마치 `static` 키워드를 사용한 것과 같은 효과를 냅니다.

```c++
#include <iostream>

namespace {
// 이 함수는 이 파일 안에서만 사용할 수 있습니다.
// 이는 마치 static int OnlyInThisFile() 과 동일합니다.
int OnlyInThisFile() {}

// 이 변수 역시 static int x 와 동일합니다.
int only_in_this_file = 0;
}  // namespace

int main() {
  OnlyInThisFile();
  only_in_this_file = 3;
}

```

--------------------------------

## 1-3

[구글픽 변수 이름 깔삼하게 짓는 팁](https://google.github.io/styleguide/cppguide.html#Variable_Names)

변수 만드는 법, 포인터 등 대부분의 문법은 c++과 c언어가 동일하다.

for문, while문, if-else문, break, switch도 동일하다.

> std::cin == 입력받기
> `std::cin >> user_input;`

**c++에서는 c언어의 scanf처럼 &연산자를 사용치 않음!**

---------------------------------------------------

## 2

참조자(레퍼런스)라는 c++만의 새로운 개념!

```c++

#include <iostream>

// 이 change_val이 참조자 개념!
int change_val(int *p) {
  *p = 3;

  return 0;
}
int main() {
  int number = 5;

  std::cout << number << std::endl;
  change_val(&number);
  std::cout << number << std::endl;
}
```

```c++
 int a = 3;
  int& another_a = a;
// 이런 거
```

>**레퍼런스 만드는 법 == 자료형 뒤에 & 붙이기, 혹은 위처럼 함수 비슷한거 만들기**

심지어 `int*` 와 같은 포인터 타입의 참조자를 만드려면 `int*&` 로 쓰면 됩니다.

위와 같이 선언함으로써 우리는 `another_a` 는 `a` 의 참조자다! 라고 공표하게 되었습니다. 이 말은 즉슨 `another_a` 는 `a` 의 또다른 이름 이라고 컴파일러에게 알려주는 것입니다. 따라서 `another_a` 에 어떠한 작업을 수행하든 이는 사실상 `a` 에 그 작업을 하는 것과 마찬가지 입니다.

어떻게 보면 참조자와 포인터는 상당히 유사한 개념입니다. 포인터 역시 다른 어떤 변수의 주소값을 보관함으로써 해당 변수에 간접적으로 연산을 수행할 수 있기 때문이죠. 하지만 레퍼런스와 포인터는 몇 가지 중요한 차이점이 있습니다.

#### 레퍼런스는 반드시 처음에 누구의 별명이 될 것인지 지정해야 합니다.

`int& another_a;` 는 불가능!
**또, const같은 존재이기에 다른 놈의 별명으로 바꾸는 것도 불가능!** 
another_ a == a랑 같은 존재가 되버린 것임!

#### 레퍼런스는 메모리 상에 존재하지 않을 수 도 있다.

만일 내가 컴파일러라면 `another_a` 위해서 메모리 상에 공간을 할당할 필요가 있을까요? 아니죠! 왜냐하면 `another_a` 가 쓰이는 자리는 모두 `a` 로 바꿔치기 하면 되니까요. 따라서 이 경우 레퍼런스는 메모리 상에 존재하지 않게 됩니다. 물론 그렇다고 해서 항상 존재하지 않은 것은 아닙니다. 아래 예제를 보실까요.

```c++
#include <iostream>

int change_val(int &p) { // 이때는 int &p가 되는 이유는, change_val이 호출될 때, int &p = number가 되는 셈이여서 가능.
  p = 3;

  return 0;
}
int main() {
  int number = 5;

  std::cout << number << std::endl;
  change_val(number);
  std::cout << number << std::endl;
}
```

이때는 아마 p가 메모리 상에 존재하게 된다는 의미 같다. 

*맞나? 사실 잘 모르겠다.*

다중 레퍼런스도 가능한데, x가 y의 별명이고, z가 y의 별명이라는 것이 아니라, x의 별명이 y,z 동일하다고 되는 느낌이다.

```c++
  int x;
  int& y = x;
  int& z = y;
```

>좋은 질문 입니다. 하지만 참조자의 참조자 라는 말의 의미를 생각해보면 사실 말이 안된다는 것을 알 수 있습니다. 굳이 별명의 별명을 만들 필요는 없으니까요! 실제로 C++ 문법 상 참조자의 참조자를 만드는 것은 금지되어 있습니다.

상수 레퍼런스는 불가능.
`int &ref = 4;` 같은 녀석. `ref = 5` 같은 미친 버그를 잡기 위해서 그럼.

다만, 앞에 const를 붙여 버그를 확실히 막아둔 경우 가능.

## 2023-01-21

#### 레퍼런스 배열은 만들 수 없다.
`int a, b; int & arr[2] = {a, b};` 는 불가능한 코드.

그런데 주소값이 존재한다라는 의미는 해당 원소가 메모리 상에서 존재한다 라는 의미와 같습니다. 하지만 레퍼런스는 특별한 경우가 아닌 이상 메모리 상에서 공간을 차지 하지 않습니다. 따라서 이러한 모순 때문에 레퍼런스들의 배열을 정의하는 것은 언어 차원에서 금지가 되어 있는 것입니다.

#### 다만, 배열들의 레퍼런스는 가능하다.

```c++
#include <iostream>

int main() {
  int arr[3] = {1, 2, 3};
  int(&ref)[3] = arr;

  ref[0] = 2;
  ref[1] = 3;
  ref[2] = 1;

  std::cout << arr[0] << arr[1] << arr[2] << std::endl;
  return 0;
}
```

따라서 `ref[0]` 부터 `ref[2]` 가 각각 `arr[0]` 부터 `arr[2]` 의 레퍼런스가 됩니다. 포인터와는 다르게 배열의 레퍼런스의 경우 참조하기 위해선 
**반드시 배열의 크기를 명시해야 합니다.**

따라서 `int (&ref)[3]` 이라면 반드시 크기가 3 인 `int` 배열의 별명이 되어야 하고 `int (&ref)[5]` 라면 크기가 5 인 `int` 배열의 별명이 되어야 합니다.

레퍼런스 리턴하는 함수도 만드는 것 가능.
다만, 레퍼런스의 본래 변수가 없어지지 않는 것(지역 변수가 아닌 것)이여야 함.

```c++
int& function() {
  int a = 2;
  return a;
}

int main() {
  int b = function();
  b = 3;
  return 0;
}
```
> 이 경우, 오류 발생. 컴파일 에러는 아니라 돌아갈수도 있지만, 위험한 작업

다만,
```c++
int& function(int& a) {
  a = 5;
  return a;
}

int main() {
  int b = 2;
  int c = function(b);
  return 0;
}
```
> 는 가능. 외부 변수의 레퍼런스를 리턴한 건데, return이 일어나는 시점에 a는 b를 참조하고 있고, function이 리턴한 참조자도 여전히 b를 참조할테니. `int c = function(b);` 라는 줄은, `int c = b`가 된 셈.


### 레퍼런스를 사용하는 이유!

그렇다면 이렇게 참조자를 리턴하는 경우의 **장점**이 무엇일까요? C 언어에서 엄청나게 큰 구조체가 있을 때 해당 구조체 변수를 그냥 리턴하면 전체 복사가 발생해야 해서 시간이 오래걸리지만, 해당 구조체를 가리키는 포인터를 리턴한다면 그냥 포인터 주소 한 번 복사로 매우 빠르게 끝납니다.

마찬가지로 레퍼런스를 리턴하게 된다면 레퍼런스가 참조하는 타입의 크기와 상관 없이 딱 한 번의 주소값 복사로 전달이 끝나게 됩니다. 따라서 매우 효율적이죠!

위의 반대의 경우로, 참조자가 아닌 값을 리턴하는 함수를 참조자로 받는것도 같음.
```c++
int function() {
  int a = 5;
  return a;
}

int main() {
  int& c = function();
  return 0;
}
```
> 코드 실행시 오류 발생. 

다만, c++에는 **매우 중요한** 예외 규칙이 있다.

```c++
#include <iostream>

int function() {
  int a = 5;
  return a;
}

int main() {
  const int& c = function();
  std::cout << "c : " << c << std::endl;
  return 0;
}
```
> 의 경우에는 정상작동 한다.

원칙상 함수의 리턴값은 해당 문장이 끝나면 소멸되는 것이 정상입니다. 따라서 기존에 `int&` 로 받았을 때에는 컴파일 자체가 안되었습니다. 하지만 예외적으로 상수 레퍼런스로 리턴값을 받게 되면 해당 리턴값의 생명이 연장됩니다. 그리고 그 연장되는 기간은 레퍼런스가 사라질 때 까지 입니다.

> 즉, 원래는 그자리에서 사라졌어야 할 함수의 리턴값이 레퍼런스가 없어질때까지 유지된다는 소리.

### 배운 내용 정리

|  Paragraph   | 함수에서 값 리턴 (`int f()`)   | 함수에서 참조자 리턴 (`int& f()`)      |
| ---        |    ---   |          --- |
| 값 타입으로 받음(`int a = f()`) | 값 복사됨       |        값 복사됨. 다만 지역 변수의 레퍼런스를 리턴하지 않도록 주의     |
| 참조자 타입으로 받음 (`int& a = f()`)| 컴파일 오류 | 가능. 다만 마찬가지로 지역 변수의 레퍼런스를 리턴하지 않도록 주의   |
| 상수 참조자 타입으로 받음 (`const int& a = f()`)|가능|가능. 다만 마찬가지로 지역 변수의 레퍼런스를 리턴하지 않도록 주의      |


[블로그 링크, 레퍼런스를 사용하는 이유와 레퍼런스가 메모리를 먹는 타이밍 관련 글](https://lecor.tistory.com/39#:~:text=%EC%9D%B4%EC%99%80%20%EA%B0%99%EC%9D%80%20%EC%B0%B8%EC%A1%B0%EC%9E%90%20%EB%A6%AC%ED%84%B4,%EC%9D%98%20%EC%9E%A5%EC%A0%90%EA%B3%BC%20%EB%8F%99%EC%9D%BC%ED%95%98%EB%8B%A4.)

레퍼런스는 더 찾아봐야 할 듯!

---------------------------------------------

## 3단원

은 22일부터...