c++ 관련 필기사항 정리 문서
========================================

[블로그 링크](https://modoocode.com/135)

## 2023-01-18

1. 왜 c++을 배우냐 부분 읽음
2. 1-1 진행함

------------------------------

## 2023-01-19

## 1-2

>iostream  == c언어에서 stdio.h 같은 존재

>std = 이름공간이라는 것(namespace)
	객체가 어디 소속인지 지정해줌

`std::cout` 에서 std가 없으면 cout를 찾을 수 없음.

```c++
// header1.h 의 내용
namespace header1 {
int foo();
void bar();
}

// header2.h 의 내용
namespace header2 {
int foo();
void bar();
}
```
> 이름공간을 정의하는 방법이다.

header1안에서 foo를 부른다면 그 안의 foo를 부르는 셈,
밖에서 부르려면 `header1::foo`가 필요.

하지만 만일 위 같은 `foo` 을 여러번 반복적으로 호출하게 되는 경우 앞에 매번 `header1::` 을 붙이기가 상당히 귀찮을 것입니다.

>그래서 아래와 같이 '나는 앞으로 `header1` 이란 이름 공간에 들어있는 `foo` 만 쓸거다!' 라고 선언할 수 있습니다.

```c++
#include "header1.h"
#include "header2.h"

using header1::foo;
int main() {
  foo();  // header1 에 있는 함수를 호출
}
////////////////////////////////////////////////////
#include "header1.h"
#include "header2.h"
// header1에 있는 공간만 사용 원할시,
using namespace header1;
int main() {
  foo();  // header1 에 있는 함수를 호출
  bar();  // header1 에 있는 함수를 호출
}
// 로 가능. 그렇다고 header2를 못 부르는 건 아니고, 명시적으로 적어주면 가능.

```

std는 iostream 안에 정의된 이름공간임.
이 경우에는, 특별히 std 생략하고 cout, endl만 적어도 가능.

**참고!** 
권장하는 방식은 `using namespace std;` 같은 것은 사용하지 않고, `std::` 를 직접 앞에 붙여서 [std](https://modoocode.com/std) 의 이름공간의 함수이다 라고 명시해주는 것이 좋습니다. 또한, 여러분이 작성하는 코드는 여러분 만의 이름 공간에 넣어서 혹시 모를 이름 충돌로 부터 보호하는 것이 중요합니다.

>cout == 표준 출력 (c언어의 stdout라네요)

>endl == 출력하겠다는 함수(대충 엔터출력정도로 지금은 생각)

잠깐 짚고 넘어가자면, C++ 에서는 재미있게도 이름 공간에 굳이 이름을 설정하지 않아도 됩니다.

이 경우 해당 이름 공간에 정의된 것들은 해당 파일 안에서만 접근할 수 있게 됩니다. 이 경우 마치 `static` 키워드를 사용한 것과 같은 효과를 냅니다.

```c++
#include <iostream>

namespace {
// 이 함수는 이 파일 안에서만 사용할 수 있습니다.
// 이는 마치 static int OnlyInThisFile() 과 동일합니다.
int OnlyInThisFile() {}

// 이 변수 역시 static int x 와 동일합니다.
int only_in_this_file = 0;
}  // namespace

int main() {
  OnlyInThisFile();
  only_in_this_file = 3;
}

```

--------------------------------

## 1-3

[구글픽 변수 이름 깔삼하게 짓는 팁](https://google.github.io/styleguide/cppguide.html#Variable_Names)

변수 만드는 법, 포인터 등 대부분의 문법은 c++과 c언어가 동일하다.

for문, while문, if-else문, break, switch도 동일하다.

> std::cin == 입력받기
> `std::cin >> user_input;`

**c++에서는 c언어의 scanf처럼 &연산자를 사용치 않음!**

---------------------------------------------------

## 2

참조자(레퍼런스)라는 c++만의 새로운 개념!

```c++

#include <iostream>

// 이 change_val이 참조자 개념!
int change_val(int *p) {
  *p = 3;

  return 0;
}
int main() {
  int number = 5;

  std::cout << number << std::endl;
  change_val(&number);
  std::cout << number << std::endl;
}
```

```c++
 int a = 3;
  int& another_a = a;
// 이런 거
```

>**레퍼런스 만드는 법 == 자료형 뒤에 & 붙이기, 혹은 위처럼 함수 비슷한거 만들기**

심지어 `int*` 와 같은 포인터 타입의 참조자를 만드려면 `int*&` 로 쓰면 됩니다.

위와 같이 선언함으로써 우리는 `another_a` 는 `a` 의 참조자다! 라고 공표하게 되었습니다. 이 말은 즉슨 `another_a` 는 `a` 의 또다른 이름 이라고 컴파일러에게 알려주는 것입니다. 따라서 `another_a` 에 어떠한 작업을 수행하든 이는 사실상 `a` 에 그 작업을 하는 것과 마찬가지 입니다.

어떻게 보면 참조자와 포인터는 상당히 유사한 개념입니다. 포인터 역시 다른 어떤 변수의 주소값을 보관함으로써 해당 변수에 간접적으로 연산을 수행할 수 있기 때문이죠. 하지만 레퍼런스와 포인터는 몇 가지 중요한 차이점이 있습니다.

#### 레퍼런스는 반드시 처음에 누구의 별명이 될 것인지 지정해야 합니다.

`int& another_a;` 는 불가능!
**또, const같은 존재이기에 다른 놈의 별명으로 바꾸는 것도 불가능!** 
another_ a == a랑 같은 존재가 되버린 것임!

#### 레퍼런스는 메모리 상에 존재하지 않을 수 도 있다.

만일 내가 컴파일러라면 `another_a` 위해서 메모리 상에 공간을 할당할 필요가 있을까요? 아니죠! 왜냐하면 `another_a` 가 쓰이는 자리는 모두 `a` 로 바꿔치기 하면 되니까요. 따라서 이 경우 레퍼런스는 메모리 상에 존재하지 않게 됩니다. 물론 그렇다고 해서 항상 존재하지 않은 것은 아닙니다. 아래 예제를 보실까요.

```c++
#include <iostream>

int change_val(int &p) { // 이때는 int &p가 되는 이유는, change_val이 호출될 때, int &p = number가 되는 셈이여서 가능.
  p = 3;

  return 0;
}
int main() {
  int number = 5;

  std::cout << number << std::endl;
  change_val(number);
  std::cout << number << std::endl;
}
```

이때는 아마 p가 메모리 상에 존재하게 된다는 의미 같다. 

*맞나? 사실 잘 모르겠다.*

다중 레퍼런스도 가능한데, x가 y의 별명이고, z가 y의 별명이라는 것이 아니라, x의 별명이 y,z 동일하다고 되는 느낌이다.

```c++
  int x;
  int& y = x;
  int& z = y;
```

>좋은 질문 입니다. 하지만 참조자의 참조자 라는 말의 의미를 생각해보면 사실 말이 안된다는 것을 알 수 있습니다. 굳이 별명의 별명을 만들 필요는 없으니까요! 실제로 C++ 문법 상 참조자의 참조자를 만드는 것은 금지되어 있습니다.

상수 레퍼런스는 불가능.
`int &ref = 4;` 같은 녀석. `ref = 5` 같은 미친 버그를 잡기 위해서 그럼.

다만, 앞에 const를 붙여 버그를 확실히 막아둔 경우 가능.

## 2023-01-21

#### 레퍼런스 배열은 만들 수 없다.
`int a, b; int & arr[2] = {a, b};` 는 불가능한 코드.

그런데 주소값이 존재한다라는 의미는 해당 원소가 메모리 상에서 존재한다 라는 의미와 같습니다. 하지만 레퍼런스는 특별한 경우가 아닌 이상 메모리 상에서 공간을 차지 하지 않습니다. 따라서 이러한 모순 때문에 레퍼런스들의 배열을 정의하는 것은 언어 차원에서 금지가 되어 있는 것입니다.

#### 다만, 배열들의 레퍼런스는 가능하다.

```c++
#include <iostream>

int main() {
  int arr[3] = {1, 2, 3};
  int(&ref)[3] = arr;

  ref[0] = 2;
  ref[1] = 3;
  ref[2] = 1;

  std::cout << arr[0] << arr[1] << arr[2] << std::endl;
  return 0;
}
```

따라서 `ref[0]` 부터 `ref[2]` 가 각각 `arr[0]` 부터 `arr[2]` 의 레퍼런스가 됩니다. 포인터와는 다르게 배열의 레퍼런스의 경우 참조하기 위해선 
**반드시 배열의 크기를 명시해야 합니다.**

따라서 `int (&ref)[3]` 이라면 반드시 크기가 3 인 `int` 배열의 별명이 되어야 하고 `int (&ref)[5]` 라면 크기가 5 인 `int` 배열의 별명이 되어야 합니다.

레퍼런스 리턴하는 함수도 만드는 것 가능.
다만, 레퍼런스의 본래 변수가 없어지지 않는 것(지역 변수가 아닌 것)이여야 함.

```c++
int& function() {
  int a = 2;
  return a;
}

int main() {
  int b = function();
  b = 3;
  return 0;
}
```
> 이 경우, 오류 발생. 컴파일 에러는 아니라 돌아갈수도 있지만, 위험한 작업

다만,
```c++
int& function(int& a) {
  a = 5;
  return a;
}

int main() {
  int b = 2;
  int c = function(b);
  return 0;
}
```
> 는 가능. 외부 변수의 레퍼런스를 리턴한 건데, return이 일어나는 시점에 a는 b를 참조하고 있고, function이 리턴한 참조자도 여전히 b를 참조할테니. `int c = function(b);` 라는 줄은, `int c = b`가 된 셈.


### 레퍼런스를 사용하는 이유!

그렇다면 이렇게 참조자를 리턴하는 경우의 **장점**이 무엇일까요? C 언어에서 엄청나게 큰 구조체가 있을 때 해당 구조체 변수를 그냥 리턴하면 전체 복사가 발생해야 해서 시간이 오래걸리지만, 해당 구조체를 가리키는 포인터를 리턴한다면 그냥 포인터 주소 한 번 복사로 매우 빠르게 끝납니다.

마찬가지로 레퍼런스를 리턴하게 된다면 레퍼런스가 참조하는 타입의 크기와 상관 없이 딱 한 번의 주소값 복사로 전달이 끝나게 됩니다. 따라서 매우 효율적이죠!

위의 반대의 경우로, 참조자가 아닌 값을 리턴하는 함수를 참조자로 받는것도 같음.
```c++
int function() {
  int a = 5;
  return a;
}

int main() {
  int& c = function();
  return 0;
}
```
> 코드 실행시 오류 발생. 

다만, c++에는 **매우 중요한** 예외 규칙이 있다.

```c++
#include <iostream>

int function() {
  int a = 5;
  return a;
}

int main() {
  const int& c = function();
  std::cout << "c : " << c << std::endl;
  return 0;
}
```
> 의 경우에는 정상작동 한다.

원칙상 함수의 리턴값은 해당 문장이 끝나면 소멸되는 것이 정상입니다. 따라서 기존에 `int&` 로 받았을 때에는 컴파일 자체가 안되었습니다. 하지만 예외적으로 상수 레퍼런스로 리턴값을 받게 되면 해당 리턴값의 생명이 연장됩니다. 그리고 그 연장되는 기간은 레퍼런스가 사라질 때 까지 입니다.

> 즉, 원래는 그자리에서 사라졌어야 할 함수의 리턴값이 레퍼런스가 없어질때까지 유지된다는 소리.

### 배운 내용 정리

|  Paragraph   | 함수에서 값 리턴 (`int f()`)   | 함수에서 참조자 리턴 (`int& f()`)      |
| ---        |    ---   |          --- |
| 값 타입으로 받음(`int a = f()`) | 값 복사됨       |        값 복사됨. 다만 지역 변수의 레퍼런스를 리턴하지 않도록 주의     |
| 참조자 타입으로 받음 (`int& a = f()`)| 컴파일 오류 | 가능. 다만 마찬가지로 지역 변수의 레퍼런스를 리턴하지 않도록 주의   |
| 상수 참조자 타입으로 받음 (`const int& a = f()`)|가능|가능. 다만 마찬가지로 지역 변수의 레퍼런스를 리턴하지 않도록 주의      |


[블로그 링크, 레퍼런스를 사용하는 이유와 레퍼런스가 메모리를 먹는 타이밍 관련 글](https://lecor.tistory.com/39#:~:text=%EC%9D%B4%EC%99%80%20%EA%B0%99%EC%9D%80%20%EC%B0%B8%EC%A1%B0%EC%9E%90%20%EB%A6%AC%ED%84%B4,%EC%9D%98%20%EC%9E%A5%EC%A0%90%EA%B3%BC%20%EB%8F%99%EC%9D%BC%ED%95%98%EB%8B%A4.)

레퍼런스는 더 찾아봐야 할 듯!

---------------------------------------------

## 3단원

### 2023-01-22

>new == c언어의 malloc 같은 존재

>delete == c언어의 free 같은 존재


```c++
/* new 와 delete 의 사용 */
#include <iostream>

int main() {
  int* p = new int;
  *p = 10;

  std::cout << *p << std::endl;

  delete p;
  return 0;
}
```

> new로 당연하지만, 배열 할당도 가능. `int *list = new int[arr_size]` 이런 식으로. 해지할땐 `delete[] list` 로 한다. new-delete 짝, new[ ] - delele[ ]짝 인 셈이다.

c++에서는 c처럼 맨 위가 아닌 중간에서도 변수선언이 되고, {} 안에서 선언한 건 그 안의 지역변수고, 중괄호 나가면 소멸된다.

c언어 방식의 struct 로 프로그램 만들던걸 이야기해주며, 객체지향을 위한 빌드업 세우고 마침.

-------------------------------------------------------------

## 4-1단원

기계어, 어셈블리어, 2세대언어, 3세대(절차지향), 이후 객체지향 소개해줌.

## 2023-01-23

객체

다시 말해서 `Animal` 자체가 `Play` 를 하는 것이지, `Play` 가 `Animal` 을 해주는 것이 아닙니다. 만일 `Animal` 자체가 `Play` 를 한다 라는 개념을 생각하게 된다면, 다음과 같이 생각할 수 있을 것입니다.

```c++
Animal animal;

// 여러가지 초기화 (생략)

animal.play();   // 즉 내가 (animal 이) Play 를 한다!
animal.sleep();  // 내가 sleep 을 한다!

```

이렇게 하면 `play` 함수에 `animal` 을 인자로 주지 않아도 됩니다. 왜냐하면 내가 `play` 하는 것이기 때문에 내 정보는 이미 `play` 함수가 다 알고 있기 때문입니다. `play` 함수는 나의 상태들, 예를 들어서 체력이나, 배고픔 정도나 피곤한 정도 등을 모두 알 수 있기 때문에 나에 대한 적절한 처리를 할 수 있게 되는 것입니다. 

즉, `animal` 은 **자신의 상태를 알려주는 변수(variable)** 과, **자신이 하는 행동들 (play, sleep 등등) 을 수행하는 함수(method) 들로 이루어졌다**고 볼 수 있습니다.

>객체란, 변수들과 참고 자료들로 이루어진 소프트웨어 덩어리 이다.

이 때 객체가 현실 세계에서의 존재하는 것들을 나타내기 위해서는 **추상화(abstraction) 라는 과정이 필요**합니다. 컴퓨터 상에서 현실 세계를 100% 나타낼 수 없는 것이기 때문에, 적절하게 컴퓨터에서 처리할 수 있도록 바꾸는 것인데, 예를 들어서 핸드폰의 경우 '전화를 한다', '문자를 보낸다' 와 같은 것들은 '핸드폰이 하는 것' 이므로 함수로 추상화시킬 수 있고,핸드폰의 상태를 나타내는 것들, 예를 들어서 자기 자신의 전화 번호나 배터리 잔량 같은 것은변수로 추상화시킬 수 있습니다.

![이미지](https://modoocode.com/img/2012E33F4F4CCAF12C29D8.gif)

이와 같이 어떠한 객체는 자기 만의 정보를 나타내는 변수들과, 이를 가지고 어떠한 작업을 하는 함수들로 둘러싸고 있다고 보시면 됩니다. 

**참고로, 이러한 객체의 변수나 함수들을 보통 인스턴스 변수(instance variable) 와 인스턴스 메소드(instance method) 라고 부르게 되는데, 그냥 알고 계시는 변수와 함수와 동일한 것으로 생각하시면 됩니다.** 

누군가 인스턴스 메소드라고 하면 "아 그냥 객체에 정의되어 있는 함수구나" 라고 생각하시면 됩니다.

**그림을 메소드가 변수들을 감싸고 있는 것 처럼 그리는 이유는 진짜로 변수들이 외부로 부터 '보호' 되고 있기 때문입니다.**

다시 말해, 외부에서 어떠한 객체의 인스턴스 변수의 값을 바꾸지 못하고오직 객체의 인스턴스 함수를 통해서만 가능하다는 것이지요.

이와 같이 외부에서 직접 인스턴스 변수의 값을 바꿀 수 없고 항상 인스턴스 메소드를 통해서 간접적으로 조절하는 것을 **캡슐화(Encapsulation)** 라고 부릅니다.

일단 여기서는 캡슐화의 장점에 대해서는 나중에 설명하겠지만 간단하게 말하자면, "객체가 내부적으로 어떻게 작동하는지 몰라도 사용할 줄 알게 된다" 라고 볼 수 있습니다.

> 클래스
> 자 그러면 객체는 C++ 상에서 어떻게 만들어낼까요. 이를 위해 C++ 에서 객체를 만들 수 있는 장치를 준비하였습니다. 쉽게 말하면 객체의 '설계도' 라고 볼 수 있지요. 바로 클래스(class) 입니다.

위와 같이 안의 내용은 차있지 않고 빈 껍질로만 생각할 수 있습니다. 그리고 우리는 이 객체의 설계도를 통해서 실제 객체를 만들게 되지요. 

**C++ 에서 이와 같이 클래스를 이용해서 만들어진 객체를 인스턴스(instance) 라고 부릅니다.**

```c++
#include <iostream>

class Animal {
 private:
  int food;
  int weight;

 public:
  void set_animal(int _food, int _weight) {
    food = _food;
    weight = _weight;
  }
  void increase_food(int inc) {
    food += inc;
    weight += (inc / 3);
  }
  void view_stat() {
    std::cout << "이 동물의 food   : " << food << std::endl;
    std::cout << "이 동물의 weight : " << weight << std::endl;
  }
};  // 세미콜론 잊지 말자!

int main() {
  Animal animal;
  animal.set_animal(100, 50);
  animal.increase_food(30);

  animal.view_stat();
  return 0;
}
```


`food, weight` 라는 변수가 있고, `set_animal, increase_food, view_stat` 이라는 함수들이 있는데, `Animal` 클래스 상에서 이들을 지칭할 때 

**각각 멤버 변수(member variable) 과 멤버 함수(member function) 라고 부릅니다.**

즉, 인스턴스로 생성된 객체에서는 인스턴스 변수, 인스턴스 함수, 그리고 그냥 클래스 상에서는 멤버 변수, 멤버 함수 라고 부르는 것입니다. 멤버 변수와 멤버 함수는 실재 하는 것이 아니지요. 인스턴스가 만들어져야 비로소 세상에 나타나는 것입니다.

먼저 멤버 변수들을 정의한 부분을 봅시다. 처음 보는 키워드가 있지요? 이러한 키워드를 '접근 지시자' 라고 하는데,외부에서 이러한 멤버들에 접근을 할 수 있냐 없냐를 지시해주는 것입니다. `private` 키워드의 경우, 아래에 쓰여진 것들은 모두 객체 내에서 보호되고 있다 라는 의미이지요. 즉, 앞서 객체 그림을 떠올리면 멤버 변수들이 안에서 보호 받고 있던 것 기억하시죠? `private` 되고 있는 모든 것들은 자기 객체 안에서만 접근할 수 있을 뿐 객체 외부에서는 접근할 수 없게 됩니다

> 즉, `private`는 외부에서 접근 불가능하고, 자기 객체 안에서만 접근 가능함. 말하자면, 내부의 멤버 함수를 통한 접근은 되나, 대놓고 `animal.food = 3` 이런거 안된다.


> `public` 이라는 것은 말 그대로 공개된 것으로 외부에서 마음껏 이용할 수 있게 됩니다. 그래서 `main` 함수에서도 이들을 마음대로 접근 가능.


아무것도 명시하지 않고 바로 class 아래 적으면, 자동으로 `private`로 인식.

------------------------------------------------

